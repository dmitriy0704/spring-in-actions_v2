# Spring In Actions.

> Проект изучения Spring Boot и сопутствующих технологий на практике по книге "
> Spring 6 in actions".
>
> Все изучаемые темы описаны в папке ./theory. Код в папке ./modules.
>
> Список тем:
> - Базовая теория
> - MVC

# Теоретические основы Spring

## Конфигурирование

Spring предлагает контейнер, часто называемый контекстом приложения Spring,
который создает компоненты приложения и управляет ими. Эти компоненты, или
bean-компоненты, объединяются внутри контекста Spring, образуя полноценное
приложение.

Акт объединения bean-компонентов основан на шаблоне, известном как внедрение
зависимостей (Dependency Injection, DI). В технологии внедрения зависимостей
компоненты не создают и не поддерживают жизненный цикл других компонентов, от
которых они зависят, а полагаются в этом на отдельный объект (контейнер),
который создаст все нужные компоненты и внедрит их в другие компоненты, которые
в них нуждаются. Обычно это делается с по мощью аргументов конструктора или
методов доступа к свойствам.

Следующий фрагмент XML объявляет два bean-компонента, InventoryService и
ProductService, и внедряет InventoryService в ProductService через аргумент
конструктора:

```xml

<bean id="inventoryService"
      class="com.example.InventoryService"/>
<bean id="productService"
      class="com.example.ProductService"/>
<constructor-arg ref="inventoryService"/>
        </bean>

```

Эта же конфигурация на Java:

```java

@Configuration
public class ServiceConfiguration {
    @Bean
    public InventoryService inventoryService() {
        return new InventoryService();
    }

    @Bean
    public ProductService productService() {
        return new ProductService(inventoryService());
    }
}
```

Аннотация @Configuration подсказывает фреймворку Spring, что это класс
конфигурации, который создает bean-компоненты для контекста Spring. Методы
класса конфигурации снабжены аннотацией @Bean, указывающей, что возвращаемые
ими объекты должны быть добавлены в контекст приложения как bean-компоненты
(где эти компоненты по умолчанию будут доступны по идентификаторам, совпадающим
с именами определяющих их методов). Явное описание конфигурации на Java или в
XML необходимо, только если Spring не может автоматически настроить компоненты.

Методы класса конфигурации снабжены аннотацией @Bean, указывающей, что
возвращаемые ими объекты должны быть добавлены в контекст приложения как
bean-компоненты (где эти компоненты по умолчанию будут доступны по
идентификаторам, совпадающим с именами определяющих их методов).

Автоматическая настройка связана с методами Spring, известными как
автоматическое связывание (autowiring) и сканирование компонентов. Используя
механизм сканирования, Spring может автоматически обнаруживать компоненты в пути
поиска классов (classpath) приложения и создавать их как bean-компоненты в
контексте приложения Spring. Механизм автоматического связывания позволяет
фреймворку Spring внедрять компоненты в другие beanкомпоненты, от которых те
зависят.

## Конфигурация Spring Boot

```java

@SpringBootApplication
public class TacoCloudApplication {
    public static void main(String[] args) {
        SpringApplication.run(TacoCloudApplication.class, args);
    }
}
```

@SpringBootApplication – это составная аннотация, объединяющая
три другие аннотации:

- @SpringBootConfiguration – определяет этот класс как класс конфигурации. В
  данный момент в этом классе не определяется никаких конфигурационных
  параметров, но если понадобится, в него можно добавить настройки Spring
  Framework. Эта аннотация, по сути, является специализированной формой
  аннотации @Configuration;
- @EnableAutoConfiguration – включает автоконфигурацию Spring Boot. Подробнее об
  автоконфигурации мы поговорим позже, а пока просто имейте в виду, что эта
  аннотация сообщает Spring Boot о необходимости автоматически настраивать любые
  компоненты, которые могут вам понадобиться;
- @ComponentScan – включает сканирование компонентов. Механизм сканирования
  позволяет объявлять другие классы с аннотациями, такими как @Component,
  @Controller и @Service, чтобы фреймворк Spring автоматически обнаруживал и
  регистрировал их как компоненты в контексте приложения Spring.
